'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('../utils/compat'),
    normalize = _require.normalize;

/**
 * Create a schema for tables
 * @param {String} opts.typeTable The type of table blocks
 * @param {String} opts.typeRow The type of row blocks
 * @param {String} opts.typeCell The type of cell blocks
 * @return {Object} A schema definition with rules to normalize tables
 */


function makeSchema(opts) {
  var _blocks;

  return {
    blocks: (_blocks = {}, _defineProperty(_blocks, opts.typeTable, {
      nodes: [{
        types: [opts.typeRow],
        min: 1
      }],
      parent: {
        objects: ['document']
      },
      normalize: normalizeChild(opts.typeRow, {
        parent_object_invalid: function parent_object_invalid(change, context) {
          var document = change.value.document;

          var furthest = document.getFurthestBlock(context.parent.key);
          var index = document.nodes.findIndex(function (n) {
            return n.key === furthest.key;
          });
          return change.moveNodeByKey(context.node.key, document.key, index + 1, {
            normalize: false
          });
        }
      })
    }), _defineProperty(_blocks, opts.typeRow, {
      nodes: [{
        types: [opts.typeCell],
        min: 1
      }],
      parent: {
        types: [opts.typeTable]
      },
      normalize: normalizeChild(opts.typeCell, {
        parent_type_invalid: function parent_type_invalid(change, context) {
          return change.wrapBlockByKey(context.node.key, opts.typeTable, { normalize: false });
        }
      })
    }), _defineProperty(_blocks, opts.typeCell, {
      nodes: [{
        objects: ['block'],
        min: 1
      }],
      parent: {
        types: [opts.typeRow]
      },
      normalize: normalize({
        child_object_invalid: function child_object_invalid(change, context) {
          return wrapChildrenInDefaultBlock(opts, change, context.node);
        },
        parent_type_invalid: function parent_type_invalid(change, context) {
          return change.wrapBlockByKey(context.node.key, opts.typeRow);
        }
      })
    }), _blocks)
  };
}

var normalizeChild = function normalizeChild(type, extraRules) {
  return normalize(Object.assign({}, extraRules, {
    child_type_invalid: function child_type_invalid(change, context) {
      return change.wrapBlockByKey(context.child.key, { type: type }, { normalize: false });
    }
  }));
};

function wrapChildrenInDefaultBlock(opts, change, node) {
  change.wrapBlockByKey(node.nodes.first().key, opts.typeDefault, {
    normalize: false
  });

  var wrapper = change.value.document.getDescendant(node.key).nodes.first();

  // Add in the remaining items
  node.nodes.rest().forEach(function (child, index) {
    return change.moveNodeByKey(child.key, wrapper.key, index + 1, {
      normalize: false
    });
  });

  return change;
}

module.exports = makeSchema;