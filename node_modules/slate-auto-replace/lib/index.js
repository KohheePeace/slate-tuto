'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isHotkey = require('is-hotkey');

var _isHotkey2 = _interopRequireDefault(_isHotkey);

var _typeOf = require('type-of');

var _typeOf2 = _interopRequireDefault(_typeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A Slate plugin to automatically replace a block when a string of matching
 * text is typed.
 *
 * @param {Object} opts
 * @return {Object}
 */

function AutoReplace() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var transform = opts.transform;

  var trigger = normalizeTrigger(opts.trigger);
  var ignoreIn = void 0;
  var onlyIn = void 0;

  if (opts.ignoreIn) ignoreIn = normalizeMatcher(opts.ignoreIn);
  if (opts.onlyIn) onlyIn = normalizeMatcher(opts.onlyIn);

  if (!transform) throw new Error('You must provide a `transform` option.');
  if (!trigger) throw new Error('You must provide a `trigger` option.');

  /**
   * On key down.
   *
   * @param {Event} event
   * @param {Change} change
   * @param {Editor} editor
   * @return {Value}
   */

  function onKeyDown(event, change, editor) {
    if (trigger(event)) {
      return replace(event, change, editor);
    }
  }

  /**
   * Replace a block's properties.
   *
   * @param {Event} event
   * @param {Change} change
   * @param {Editor} editor
   * @return {Value}
   */

  function replace(event, change, editor) {
    var value = change.value;

    if (value.isExpanded) return;

    var startBlock = value.startBlock;

    if (!startBlock) return;

    var type = startBlock.type;
    if (onlyIn && !onlyIn(type)) return;
    if (ignoreIn && ignoreIn(type)) return;

    var matches = getMatches(value);
    if (!matches) return;

    event.preventDefault();

    var startOffset = value.startOffset;
    var totalRemoved = 0;
    var offsets = getOffsets(matches, startOffset);

    offsets.forEach(function (offset) {
      change.moveOffsetsTo(offset.start, offset.end).delete();
      totalRemoved += offset.total;
    });

    startOffset -= totalRemoved;
    change.moveOffsetsTo(startOffset, startOffset);

    return change.call(transform, event, matches, editor);
  }

  /**
   * Try to match the current text of a `value` with the `before` and
   * `after` regexes.
   *
   * @param {Value} value
   * @return {Object}
   */

  function getMatches(value) {
    var startText = value.startText,
        startOffset = value.startOffset;
    var text = startText.text;

    var after = null;
    var before = null;

    if (opts.after) {
      var string = text.slice(startOffset);
      after = string.match(opts.after);
    }

    if (opts.before) {
      var _string = text.slice(0, startOffset);
      before = _string.match(opts.before);
    }

    // If both sides, require that both are matched, otherwise null.
    if (opts.before && opts.after && !before) after = null;
    if (opts.before && opts.after && !after) before = null;

    // Return null unless we have a match.
    if (!before && !after) return null;

    if (after) after[0] = after[0].replace(/\s+$/, '');
    if (before) before[0] = before[0].replace(/^\s+/, '');

    return { before: before, after: after };
  }

  /**
   * Return the offsets for `matches` with `start` offset.
   *
   * @param {Object} matches
   * @param {Number} start
   * @return {Object}
   */

  function getOffsets(matches, start) {
    var before = matches.before,
        after = matches.after;

    var offsets = [];
    var totalRemoved = 0;

    if (before) {
      var match = before[0];
      var startOffset = 0;
      var matchIndex = 0;

      before.slice(1, before.length).forEach(function (current) {
        if (current === undefined) return;

        matchIndex = match.indexOf(current, matchIndex);
        startOffset = start - totalRemoved + matchIndex - match.length;

        offsets.push({
          start: startOffset,
          end: startOffset + current.length,
          total: current.length
        });

        totalRemoved += current.length;
        matchIndex += current.length;
      });
    }

    if (after) {
      var _match = after[0];
      var _startOffset = 0;
      var _matchIndex = 0;

      after.slice(1, after.length).forEach(function (current) {
        if (current === undefined) return;

        _matchIndex = _match.indexOf(current, _matchIndex);
        _startOffset = start - totalRemoved + _matchIndex;

        offsets.push({
          start: _startOffset,
          end: _startOffset + current.length,
          total: 0
        });

        totalRemoved += current.length;
        _matchIndex += current.length;
      });
    }

    return offsets;
  }

  /**
   * Return the plugin.
   *
   * @type {Object}
   */

  return { onKeyDown: onKeyDown };
}

/**
 * Normalize a `trigger` option to a matching function.
 *
 * @param {Mixed} trigger
 * @return {Function}
 */

function normalizeTrigger(trigger) {
  switch ((0, _typeOf2.default)(trigger)) {
    case 'function':
      return trigger;
    case 'regexp':
      return function (event) {
        return !!(event.key && event.key.match(trigger));
      };
    case 'string':
      return (0, _isHotkey2.default)(trigger);
  }
}

/**
 * Normalize a node matching plugin option.
 *
 * @param {Function|Array|String} matchIn
 * @return {Function}
 */

function normalizeMatcher(matcher) {
  switch ((0, _typeOf2.default)(matcher)) {
    case 'function':
      return matcher;
    case 'array':
      return function (node) {
        return matcher.includes(node);
      };
    case 'string':
      return function (node) {
        return node == matcher;
      };
  }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = AutoReplace;