(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SlateAutoReplace = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var toString = Object.prototype.toString

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function'
    case '[object Date]': return 'date'
    case '[object RegExp]': return 'regexp'
    case '[object Arguments]': return 'arguments'
    case '[object Array]': return 'array'
    case '[object String]': return 'string'
  }

  if (typeof val == 'object' && val && typeof val.length == 'number') {
    try {
      if (typeof val.callee == 'function') return 'arguments';
    } catch (ex) {
      if (ex instanceof TypeError) {
        return 'arguments';
      }
    }
  }

  if (val === null) return 'null'
  if (val === undefined) return 'undefined'
  if (val && val.nodeType === 1) return 'element'
  if (val === Object(val)) return 'object'

  return typeof val
}

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Is Mac?
 *
 * @type {Boolean}
 */

var IS_MAC = typeof window != 'undefined' && window.navigator && window.navigator.platform && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

/**
 * Convenience aliases.
 *
 * @type {Object}
 */

var CONVENIENCE = {
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta',
  // The icon equivalents, for people who get weird.
  '↩': 'enter',
  '⇧': 'shift',
  '⌃': 'control',
  '⌘': 'meta',
  '⌥': 'alt',
  // Since `+` is used as a separator, we need a special case for this.
  add: '+'

  /**
   * Modifier keys.
   *
   * @type {Array}
   */

};var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'

  /**
   * Test whether an `event` matches a `hotkey` string.
   *
   * If you omit the `event`, the comparison function will be curried, to improve
   * performance by not having to parse the hotkey string on each invocation.
   *
   * @param {String} hotkey
   * @param {Event} [event]
   * @return {Boolean|Function}
   */

};function isHotkey(hotkey, event) {
  var object = parseHotkey(hotkey);

  return event == null ? function (e) {
    return compareHotkey(object, e);
  } : compareHotkey(object, event);
}

/**
 * Parse a `hotkey` string into an object.
 *
 * @param {String} hotkey
 * @return {Object}
 */

function parseHotkey(hotkey) {
  // Special case to replace `++` with `+add` to handle matching the plus key.
  hotkey = hotkey.replace('++', '+add');

  var values = hotkey.split('+');
  var length = values.length;

  var ret = {};

  // Ensure that any modifier that isn't explicitly set is set to `false`.
  for (var k in MODIFIERS) {
    var m = MODIFIERS[k];
    ret[m] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      value = value.toLowerCase();

      if (value == 'mod') {
        value = IS_MAC ? 'cmd' : 'ctrl';
      }

      if (value in CONVENIENCE) {
        value = CONVENIENCE[value];
      }

      var _m = MODIFIERS[value];

      if (length == 1 || !_m) {
        ret.key = value;
      }

      if (_m) {
        ret[_m] = true;
      }

      // If there's only one key, and it's not a modifier, ignore the shift key
      // because it will already be taken into accout by the `event.key` value.
      if (length == 1 && !_m) {
        ret.shiftKey = null;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare a hotkey `object` to an `event` to see if they match.
 *
 * @param {Object} object
 * @param {Event} event
 * @return {Boolean}
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var actual = key == 'key' ? event.key.toLowerCase() : event[key];
    var expected = object[key];
    if (expected != null && actual != expected) return false;
  }

  return true;
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isHotkey = require('is-hotkey');

var _isHotkey2 = _interopRequireDefault(_isHotkey);

var _typeOf = require('type-of');

var _typeOf2 = _interopRequireDefault(_typeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A Slate plugin to automatically replace a block when a string of matching
 * text is typed.
 *
 * @param {Object} opts
 * @return {Object}
 */

function AutoReplace() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var transform = opts.transform;

  var trigger = normalizeTrigger(opts.trigger);
  var ignoreIn = void 0;
  var onlyIn = void 0;

  if (opts.ignoreIn) ignoreIn = normalizeMatcher(opts.ignoreIn);
  if (opts.onlyIn) onlyIn = normalizeMatcher(opts.onlyIn);

  if (!transform) throw new Error('You must provide a `transform` option.');
  if (!trigger) throw new Error('You must provide a `trigger` option.');

  /**
   * On key down.
   *
   * @param {Event} event
   * @param {Change} change
   * @param {Editor} editor
   * @return {Value}
   */

  function onKeyDown(event, change, editor) {
    if (trigger(event)) {
      return replace(event, change, editor);
    }
  }

  /**
   * Replace a block's properties.
   *
   * @param {Event} event
   * @param {Change} change
   * @param {Editor} editor
   * @return {Value}
   */

  function replace(event, change, editor) {
    var value = change.value;

    if (value.isExpanded) return;

    var startBlock = value.startBlock;

    if (!startBlock) return;

    var type = startBlock.type;
    if (onlyIn && !onlyIn(type)) return;
    if (ignoreIn && ignoreIn(type)) return;

    var matches = getMatches(value);
    if (!matches) return;

    event.preventDefault();

    var startOffset = value.startOffset;
    var totalRemoved = 0;
    var offsets = getOffsets(matches, startOffset);

    offsets.forEach(function (offset) {
      change.moveOffsetsTo(offset.start, offset.end).delete();
      totalRemoved += offset.total;
    });

    startOffset -= totalRemoved;
    change.moveOffsetsTo(startOffset, startOffset);

    return change.call(transform, event, matches, editor);
  }

  /**
   * Try to match the current text of a `value` with the `before` and
   * `after` regexes.
   *
   * @param {Value} value
   * @return {Object}
   */

  function getMatches(value) {
    var startText = value.startText,
        startOffset = value.startOffset;
    var text = startText.text;

    var after = null;
    var before = null;

    if (opts.after) {
      var string = text.slice(startOffset);
      after = string.match(opts.after);
    }

    if (opts.before) {
      var _string = text.slice(0, startOffset);
      before = _string.match(opts.before);
    }

    // If both sides, require that both are matched, otherwise null.
    if (opts.before && opts.after && !before) after = null;
    if (opts.before && opts.after && !after) before = null;

    // Return null unless we have a match.
    if (!before && !after) return null;

    if (after) after[0] = after[0].replace(/\s+$/, '');
    if (before) before[0] = before[0].replace(/^\s+/, '');

    return { before: before, after: after };
  }

  /**
   * Return the offsets for `matches` with `start` offset.
   *
   * @param {Object} matches
   * @param {Number} start
   * @return {Object}
   */

  function getOffsets(matches, start) {
    var before = matches.before,
        after = matches.after;

    var offsets = [];
    var totalRemoved = 0;

    if (before) {
      var match = before[0];
      var startOffset = 0;
      var matchIndex = 0;

      before.slice(1, before.length).forEach(function (current) {
        if (current === undefined) return;

        matchIndex = match.indexOf(current, matchIndex);
        startOffset = start - totalRemoved + matchIndex - match.length;

        offsets.push({
          start: startOffset,
          end: startOffset + current.length,
          total: current.length
        });

        totalRemoved += current.length;
        matchIndex += current.length;
      });
    }

    if (after) {
      var _match = after[0];
      var _startOffset = 0;
      var _matchIndex = 0;

      after.slice(1, after.length).forEach(function (current) {
        if (current === undefined) return;

        _matchIndex = _match.indexOf(current, _matchIndex);
        _startOffset = start - totalRemoved + _matchIndex;

        offsets.push({
          start: _startOffset,
          end: _startOffset + current.length,
          total: 0
        });

        totalRemoved += current.length;
        _matchIndex += current.length;
      });
    }

    return offsets;
  }

  /**
   * Return the plugin.
   *
   * @type {Object}
   */

  return { onKeyDown: onKeyDown };
}

/**
 * Normalize a `trigger` option to a matching function.
 *
 * @param {Mixed} trigger
 * @return {Function}
 */

function normalizeTrigger(trigger) {
  switch ((0, _typeOf2.default)(trigger)) {
    case 'function':
      return trigger;
    case 'regexp':
      return function (event) {
        return !!(event.key && event.key.match(trigger));
      };
    case 'string':
      return (0, _isHotkey2.default)(trigger);
  }
}

/**
 * Normalize a node matching plugin option.
 *
 * @param {Function|Array|String} matchIn
 * @return {Function}
 */

function normalizeMatcher(matcher) {
  switch ((0, _typeOf2.default)(matcher)) {
    case 'function':
      return matcher;
    case 'array':
      return function (node) {
        return matcher.includes(node);
      };
    case 'string':
      return function (node) {
        return node == matcher;
      };
  }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = AutoReplace;

},{"is-hotkey":2,"type-of":1}]},{},[3])(3)
});