'use strict';

var _require = require('immutable'),
    Range = _require.Range;

var createCell = require('../utils/createCell');

var _require2 = require('../utils/compat'),
    validateRules = _require2.validateRules;

/**
 * Create a schema for tables
 * @param {String} opts.typeTable The type of table blocks
 * @param {String} opts.typeRow The type of row blocks
 * @param {String} opts.typeCell The type of cell blocks
 * @return {Object} A schema definition with rules to normalize tables
 */


function validateNode(opts) {
  return validateRules([rowsContainRequiredColumns(opts)]);
}

/**
 * @param {String} opts.typeTable The type of table blocks
 * @param {String} opts.typeRow The type of row blocks
 * @param {String} opts.typeCell The type of cell blocks
 * @return {Object} A rule that ensures rows contains only cells, and
 * as much cells as there is columns in the table.
 */
function rowsContainRequiredColumns(opts) {
  var isRow = function isRow(node) {
    return node.type === opts.typeRow;
  };
  var isCell = function isCell(node) {
    return node.type === opts.typeCell;
  };
  var countCells = function countCells(row) {
    return row.nodes.count(isCell);
  };

  return {
    match: function match(node) {
      return node.type === opts.typeTable;
    },
    validate: function validate(table) {
      var rows = table.nodes.filter(isRow);

      // The number of column this table has
      var columns = rows.reduce(function (count, row) {
        return Math.max(count, countCells(row));
      }, 1); // Min 1 column

      // else normalize, by padding with empty cells
      var invalidRows = rows.map(function (row) {
        var cells = countCells(row);
        var invalids = row.nodes.filterNot(isCell);

        // Row is valid: right count of cells and no extra node
        if (invalids.isEmpty() && cells === columns) {
          return null;
        }

        // Otherwise, remove the invalids and append the missing cells
        return {
          row: row,
          invalids: invalids,
          add: columns - cells
        };
      }).filter(Boolean);

      return invalidRows.size > 0 ? invalidRows : null;
    },


    /**
         * Updates by key every given nodes
         * @param {List<Nodes>} value.toUpdate
         */
    normalize: function normalize(change, node, rows) {
      rows.forEach(function (_ref) {
        var row = _ref.row,
            invalids = _ref.invalids,
            add = _ref.add;

        invalids.forEach(function (child) {
          return change.removeNodeByKey(child.key, { normalize: false });
        });

        Range(0, add).forEach(function () {
          var cell = createCell(opts);
          return change.insertNodeByKey(row.key, 0, cell, { normalize: false });
        });
      });
    }
  };
}

module.exports = validateNode;